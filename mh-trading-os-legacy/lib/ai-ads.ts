import OpenAI from "openai";
import { sheetsService } from './sheets';
import { nanoid } from 'nanoid';
import type { AdsCreative, AdsAdGroup, AIAgentsLog } from '@shared/schema';

const openai = new OpenAI({
  baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL,
  apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY
});

const AGENT_ID = 'A-ADS-120';
const MODEL = 'gpt-5'; // the newest OpenAI model is "gpt-5" which was released August 7, 2025. do not change this unless explicitly requested by the user

interface KeywordExpansionRequest {
  seedKeywords: string[]; // Base keywords
  language: 'DE' | 'EN';
  matchType?: 'Exact' | 'Phrase' | 'Broad';
}

interface AdCopyRequest {
  keywords: string[]; // Target keywords
  productName?: string;
  finalURL: string;
  language: 'DE' | 'EN';
  callToAction?: string;
}

async function logAgentOperation(
  requestType: 'keywords' | 'copy',
  inputSheets: string,
  outputSheets: string,
  status: 'pending' | 'completed' | 'failed',
  rowsCreated: number,
  promptTokens: number,
  completionTokens: number,
  error?: string
): Promise<void> {
  const totalTokens = promptTokens + completionTokens;
  // GPT-5 pricing (Nov 2025): €1.08/1M input, €8.65/1M output
  const costEUR = (promptTokens / 1000000) * 1.08 + (completionTokens / 1000000) * 8.65;

  const logEntry: Partial<AIAgentsLog> = {
    LogID: nanoid(12),
    AgentID: AGENT_ID,
    RequestType: requestType,
    InputSheets: inputSheets,
    OutputSheets: outputSheets,
    Status: status,
    CreatedTS: new Date().toISOString(),
    CompletedTS: status !== 'pending' ? new Date().toISOString() : undefined,
    RowsCreated: rowsCreated,
    PromptTokens: promptTokens,
    CompletionTokens: completionTokens,
    TotalTokens: totalTokens,
    CostEUR: costEUR,
    Notes: error || undefined,
  };

  await sheetsService.writeRows('AI_Agents_Log', [logEntry]);
}

export async function expandKeywords(request: KeywordExpansionRequest): Promise<AdsAdGroup> {
  const startTime = Date.now();
  let usage = { promptTokens: 0, completionTokens: 0 };

  try {
    const seedText = request.seedKeywords.join('\n');
    const lang = request.language.toUpperCase();

    const prompt = `You are a Google Ads keyword strategist. Expand these seed keywords into a complete keyword list with negative keywords.

Seed Keywords:
${seedText}

Language: ${lang === 'DE' ? 'German' : 'English'}
Match Type: ${request.matchType || 'Phrase'}

Generate a JSON object with:
{
  "keywords": ["keyword 1", "keyword 2", ...],  // 20-50 relevant variations
  "negativeKeywords": ["negative 1", "negative 2", ...]  // 10-20 negative keywords to exclude irrelevant traffic
}

Requirements:
- Expand seed keywords into semantic variations
- Include long-tail keywords (3-5 words)
- Add location modifiers if relevant
- Include brand variations
- Negative keywords should exclude: competitors, free/cheap seekers, job seekers, DIY/tutorial searches
- Use ${lang === 'DE' ? 'German' : 'English'} language`;

    const response = await openai.chat.completions.create({
      model: MODEL,
      messages: [{ role: "user", content: prompt }],
      response_format: { type: "json_object" },
      max_completion_tokens: 2048,
    });

    usage.promptTokens = response.usage?.prompt_tokens || 0;
    usage.completionTokens = response.usage?.completion_tokens || 0;

    const result = JSON.parse(response.choices[0]?.message?.content || '{}');

    const adGroup: AdsAdGroup = {
      AdGroupID: nanoid(12),
      CampaignID: undefined,
      AdGroupName: `${request.seedKeywords[0]}_AdGroup`,
      Keywords: result.keywords?.join('\n'),
      NegativeKeywords: result.negativeKeywords?.join('\n'),
      MatchType: request.matchType || 'Phrase',
      BidEUR: undefined,
      CreatedTS: new Date().toISOString(),
      Status: 'draft',
      Notes: `Generated by ${AGENT_ID} from ${request.seedKeywords.length} seed keywords in ${Date.now() - startTime}ms`,
    };

    await sheetsService.writeRows('Ads_AdGroups', [adGroup]);

    await logAgentOperation(
      'keywords',
      'SEO_Keywords, Ads_Keywords',
      'Ads_AdGroups',
      'completed',
      1,
      usage.promptTokens,
      usage.completionTokens
    );

    return adGroup;
  } catch (error: any) {
    await logAgentOperation(
      'keywords',
      'SEO_Keywords, Ads_Keywords',
      'Ads_AdGroups',
      'failed',
      0,
      usage.promptTokens,
      usage.completionTokens,
      error.message
    );
    throw error;
  }
}

export async function generateAdCopy(request: AdCopyRequest): Promise<AdsCreative> {
  const startTime = Date.now();
  let usage = { promptTokens: 0, completionTokens: 0 };

  try {
    const keywordsText = request.keywords.join('\n');
    const lang = request.language.toUpperCase();

    const prompt = `You are a Google Ads copywriter. Generate RSA (Responsive Search Ad) copy for this campaign.

Keywords:
${keywordsText}

Product: ${request.productName || 'Premium product'}
Landing URL: ${request.finalURL}
CTA: ${request.callToAction || 'Shop Now'}
Language: ${lang === 'DE' ? 'German' : 'English'}

Generate a JSON object with:
{
  "headlines": ["headline 1", "headline 2", ...],  // 10-15 headlines, each ≤30 characters
  "descriptions": ["desc 1", "desc 2", ...],  // 4-5 descriptions, each ≤90 characters
  "callToAction": "CTA text"
}

RSA Requirements:
- Headlines: 10-15 variations, each ≤30 chars, include keywords, numbers, benefits, urgency
- Descriptions: 4-5 variations, each ≤90 chars, unique selling points, offers, social proof
- Use ${lang === 'DE' ? 'German' : 'English'} language
- Be persuasive and action-oriented
- Include price/offer details if applicable
- Follow Google Ads best practices`;

    const response = await openai.chat.completions.create({
      model: MODEL,
      messages: [{ role: "user", content: prompt }],
      response_format: { type: "json_object" },
      max_completion_tokens: 2048,
    });

    usage.promptTokens = response.usage?.prompt_tokens || 0;
    usage.completionTokens = response.usage?.completion_tokens || 0;

    const result = JSON.parse(response.choices[0]?.message?.content || '{}');

    // Validate and truncate to RSA limits
    const headlines = (result.headlines || []).map((h: string) => h.substring(0, 30));
    const descriptions = (result.descriptions || []).map((d: string) => d.substring(0, 90));

    const creative: AdsCreative = {
      CreativeID: nanoid(12),
      AdGroupID: undefined,
      Format: 'RSA',
      Headlines: headlines.join('|'), // Pipe-separated
      Descriptions: descriptions.join('|'), // Pipe-separated
      CallToAction: result.callToAction || request.callToAction,
      FinalURL: request.finalURL,
      Language: request.language,
      CreatedTS: new Date().toISOString(),
      Status: 'draft',
      LastAIUpdateTS: new Date().toISOString(),
      Notes: `Generated by ${AGENT_ID}: ${headlines.length} headlines, ${descriptions.length} descriptions in ${Date.now() - startTime}ms`,
    };

    await sheetsService.writeRows('Ads_Creatives', [creative]);

    await logAgentOperation(
      'copy',
      'SEO_Keywords, Ads_Keywords',
      'Ads_Creatives',
      'completed',
      1,
      usage.promptTokens,
      usage.completionTokens
    );

    return creative;
  } catch (error: any) {
    await logAgentOperation(
      'copy',
      'SEO_Keywords, Ads_Keywords',
      'Ads_Creatives',
      'failed',
      0,
      usage.promptTokens,
      usage.completionTokens,
      error.message
    );
    throw error;
  }
}
