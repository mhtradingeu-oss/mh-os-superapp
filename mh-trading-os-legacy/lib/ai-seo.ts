import OpenAI from "openai";
import { sheetsService } from './sheets';
import { nanoid } from 'nanoid';
import type { SEOBrief, SEOAudit, AIAgentsLog } from '@shared/schema';

const openai = new OpenAI({
  baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL,
  apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY
});

const AGENT_ID = 'A-SEO-110';
const MODEL = 'gpt-5'; // the newest OpenAI model is "gpt-5" which was released August 7, 2025. do not change this unless explicitly requested by the user

interface BriefRequest {
  keywords: string[]; // Keywords to target
  language: 'DE' | 'EN';
  targetURL?: string;
  productSKUs?: string[]; // Optional product SKUs to feature
}

interface AuditRequest {
  pageURL: string;
  currentTitle?: string;
  currentMeta?: string;
  currentH1?: string;
  currentContent?: string;
}

async function logAgentOperation(
  requestType: 'brief' | 'audit',
  inputSheets: string,
  outputSheets: string,
  status: 'pending' | 'completed' | 'failed',
  rowsCreated: number,
  promptTokens: number,
  completionTokens: number,
  error?: string
): Promise<void> {
  const totalTokens = promptTokens + completionTokens;
  // GPT-5 pricing (Nov 2025): €1.08/1M input, €8.65/1M output
  const costEUR = (promptTokens / 1000000) * 1.08 + (completionTokens / 1000000) * 8.65;

  const logEntry: Partial<AIAgentsLog> = {
    LogID: nanoid(12),
    AgentID: AGENT_ID,
    RequestType: requestType,
    InputSheets: inputSheets,
    OutputSheets: outputSheets,
    Status: status,
    CreatedTS: new Date().toISOString(),
    CompletedTS: status !== 'pending' ? new Date().toISOString() : undefined,
    RowsCreated: rowsCreated,
    PromptTokens: promptTokens,
    CompletionTokens: completionTokens,
    TotalTokens: totalTokens,
    CostEUR: costEUR,
    Notes: error || undefined,
  };

  await sheetsService.writeRows('AI_Agents_Log', [logEntry]);
}

export async function generateSEOBrief(request: BriefRequest): Promise<SEOBrief> {
  const startTime = Date.now();
  let usage = { promptTokens: 0, completionTokens: 0 };

  try {
    const keywordsText = request.keywords.join('\n');
    const skusText = request.productSKUs?.join(', ') || 'N/A';
    const lang = request.language.toUpperCase();

    const prompt = `You are an SEO content strategist. Generate a complete SEO content brief in ${lang === 'DE' ? 'German' : 'English'}.

Target Keywords (primary keywords for this page):
${keywordsText}

Featured Products SKUs: ${skusText}

Generate a JSON object with the following structure:
{
  "title": "SEO-optimized page title (max 60 chars)",
  "metaDescription": "Compelling meta description (max 160 chars)",
  "h1": "Main heading (max 70 chars)",
  "contentOutline": "Section 1: Introduction\\nSection 2: Benefits\\nSection 3: Product Features\\nSection 4: How to Use\\nSection 5: FAQ\\nSection 6: Conclusion",
  "wordCount": 1200
}

Requirements:
- Title must include primary keyword and be ≤60 characters
- Meta description must be compelling and ≤160 characters
- H1 must be clear and ≤70 characters
- Content outline should be newline-separated sections
- Word count should be 800-2000 words
- Use ${lang === 'DE' ? 'German' : 'English'} language
- Focus on SEO best practices and user intent`;

    const response = await openai.chat.completions.create({
      model: MODEL,
      messages: [{ role: "user", content: prompt }],
      response_format: { type: "json_object" },
      max_completion_tokens: 2048,
    });

    usage.promptTokens = response.usage?.prompt_tokens || 0;
    usage.completionTokens = response.usage?.completion_tokens || 0;

    const result = JSON.parse(response.choices[0]?.message?.content || '{}');

    const brief: SEOBrief = {
      BriefID: nanoid(12),
      TargetURL: request.targetURL,
      Language: request.language,
      Keywords: keywordsText,
      Title: result.title?.substring(0, 60),
      MetaDescription: result.metaDescription?.substring(0, 160),
      H1: result.h1?.substring(0, 70),
      ContentOutline: result.contentOutline,
      WordCount: result.wordCount,
      ProductSKUs: skusText === 'N/A' ? undefined : skusText,
      CreatedTS: new Date().toISOString(),
      Status: 'draft',
      LastAIUpdateTS: new Date().toISOString(),
      Notes: `Generated by ${AGENT_ID} in ${Date.now() - startTime}ms`,
    };

    await sheetsService.writeRows('SEO_Briefs', [brief]);

    await logAgentOperation(
      'brief',
      'SEO_Keywords, FinalPriceList',
      'SEO_Briefs',
      'completed',
      1,
      usage.promptTokens,
      usage.completionTokens
    );

    return brief;
  } catch (error: any) {
    await logAgentOperation(
      'brief',
      'SEO_Keywords, FinalPriceList',
      'SEO_Briefs',
      'failed',
      0,
      usage.promptTokens,
      usage.completionTokens,
      error.message
    );
    throw error;
  }
}

export async function auditPage(request: AuditRequest): Promise<SEOAudit[]> {
  const startTime = Date.now();
  let usage = { promptTokens: 0, completionTokens: 0 };

  try {
    const prompt = `You are an SEO technical auditor. Analyze this page and suggest on-page optimizations.

Page URL: ${request.pageURL}
Current Title: ${request.currentTitle || 'Not provided'}
Current Meta Description: ${request.currentMeta || 'Not provided'}
Current H1: ${request.currentH1 || 'Not provided'}
Content Sample: ${request.currentContent?.substring(0, 500) || 'Not provided'}

Generate a JSON array of audit findings. Each finding should have:
{
  "issueType": "title" | "meta" | "headings" | "content" | "images" | "links",
  "severity": "high" | "medium" | "low",
  "currentValue": "What is currently present",
  "recommendedFix": "Specific recommendation to fix this"
}

Focus on:
- Title tag optimization (length, keywords, uniqueness)
- Meta description optimization (length, call-to-action)
- Heading structure (H1 uniqueness, H2-H6 hierarchy)
- Content quality and keyword usage
- Image alt text and optimization
- Internal linking opportunities

Return a JSON array of findings.`;

    const response = await openai.chat.completions.create({
      model: MODEL,
      messages: [{ role: "user", content: prompt }],
      response_format: { type: "json_object" },
      max_completion_tokens: 2048,
    });

    usage.promptTokens = response.usage?.prompt_tokens || 0;
    usage.completionTokens = response.usage?.completion_tokens || 0;

    const resultText = response.choices[0]?.message?.content || '{}';
    const parsed = JSON.parse(resultText);
    const findings = Array.isArray(parsed.findings) ? parsed.findings : 
                    Array.isArray(parsed) ? parsed : 
                    [parsed];

    const audits: SEOAudit[] = findings.map((finding: any) => ({
      AuditID: nanoid(12),
      PageURL: request.pageURL,
      IssueType: finding.issueType,
      Severity: finding.severity,
      CurrentValue: finding.currentValue,
      RecommendedFix: finding.recommendedFix,
      CreatedTS: new Date().toISOString(),
      Status: 'pending',
      Notes: `Generated by ${AGENT_ID}`,
    }));

    if (audits.length > 0) {
      await sheetsService.writeRows('SEO_Audits', audits);
    }

    await logAgentOperation(
      'audit',
      'SEO_Pages',
      'SEO_Audits',
      'completed',
      audits.length,
      usage.promptTokens,
      usage.completionTokens
    );

    return audits;
  } catch (error: any) {
    await logAgentOperation(
      'audit',
      'SEO_Pages',
      'SEO_Audits',
      'failed',
      0,
      usage.promptTokens,
      usage.completionTokens,
      error.message
    );
    throw error;
  }
}
