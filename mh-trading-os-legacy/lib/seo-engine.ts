import OpenAI from "openai";
import { sheetsService } from "./sheets";
import { nanoid } from "nanoid";
import { retryWithBackoff } from "./retry";

const openai = new OpenAI({
  baseURL: process.env.AI_INTEGRATIONS_OPENAI_BASE_URL,
  apiKey: process.env.AI_INTEGRATIONS_OPENAI_API_KEY
});

interface HarvestKeywordsInput {
  seedTerms: string[];
  locale: "en" | "de";
  source?: "AI" | "API";
}

interface KeywordData {
  Keyword: string;
  Locale: string;
  Intent: "Informational" | "Commercial" | "Transactional" | "Navigational";
  Cluster: string;
  Volume_Est: string;
  KD_Est: string;
  CPC_EUR_Est: string;
  BusinessFit: string;
  Notes: string;
}

interface ClusterResult {
  keyword: string;
  cluster: string;
  intent: string;
}

interface PriorityResult {
  keyword: string;
  priorityScore: number;
}

interface SEOBrief {
  BriefID: string;
  Keyword: string;
  TargetURL: string;
  TitleTag: string;
  MetaDescription: string;
  H1: string;
  OutlineJSON: string;
  InternalLinksCSV: string;
  Status: string;
  AssignedTo: string;
  CreatedAt: string;
  Notes: string;
}

interface OnPageSuggestion {
  url: string;
  titleSuggestion: string;
  h1Suggestion: string;
  metaSuggestion: string;
  wordCountTarget: number;
  h2sSuggested: string;
  quickWins: string;
}

/**
 * A-SEO-201 "Keyword Harvester"
 * Generates keywords from seed terms using AI
 */
export async function harvestKeywords(input: HarvestKeywordsInput): Promise<KeywordData[]> {
  const { seedTerms, locale, source = "AI" } = input;

  const prompt = `You are A-SEO-201 "Keyword Harvester", an AI specialized in SEO keyword research for B2B trading operations.

Generate a comprehensive list of 20-50 relevant keywords based on these seed terms: ${seedTerms.join(", ")}

**Language**: ${locale === "de" ? "German (Deutsch)" : "English"}
**Context**: MH Trading OS - B2B trading platform for beard care, hair care, skincare, and grooming products in Germany and Europe.

For each keyword, provide:
1. **Keyword**: The actual keyword phrase (in ${locale === "de" ? "German" : "English"})
2. **Intent**: One of: Informational, Commercial, Transactional, Navigational
3. **Cluster**: A thematic cluster name (e.g., "Beard Care", "Hair Growth", "Product Reviews")
4. **Volume_Est**: Estimated monthly search volume (e.g., "800", "1200", "5000")
5. **KD_Est**: Estimated keyword difficulty 0-100 (e.g., "45", "68")
6. **CPC_EUR_Est**: Estimated CPC in EUR (e.g., "0.85", "1.20")
7. **BusinessFit**: How well it fits our business: "HIGH", "MEDIUM", "LOW"

**Requirements**:
- Mix of all intent types (Informational, Commercial, Transactional)
- Varied difficulty levels (easy, medium, hard)
- Keywords should cover product categories, how-to guides, comparisons, and buying intent
- Include both short-tail and long-tail keywords
- Focus on German market preferences

Return ONLY a JSON array of keyword objects. No additional text.`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        {
          role: "system",
          content: "You are A-SEO-201, an expert SEO keyword researcher. You provide detailed, accurate keyword data in JSON format only."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      max_completion_tokens: 4096,
    });

    const content = response.choices[0]?.message?.content || "{}";
    const parsed = JSON.parse(content);
    const keywords = parsed.keywords || [];

    const keywordData: KeywordData[] = keywords.map((kw: any) => ({
      Keyword: kw.keyword || kw.Keyword || "",
      Locale: locale,
      Intent: kw.intent || kw.Intent || "Informational",
      Cluster: kw.cluster || kw.Cluster || "Uncategorized",
      Volume_Est: String(kw.volume || kw.Volume_Est || "0"),
      KD_Est: String(kw.difficulty || kw.KD_Est || "50"),
      CPC_EUR_Est: String(kw.cpc || kw.CPC_EUR_Est || "0.00"),
      BusinessFit: kw.businessFit || kw.BusinessFit || "MEDIUM",
      Notes: `AI-generated by A-SEO-201 from seeds: ${seedTerms.join(", ")}`
    }));

    await logToAIOutbox({
      agentId: "A-SEO-201",
      task: "harvest-keywords",
      input: JSON.stringify(input),
      output: JSON.stringify({ count: keywordData.length }),
      status: "SUCCESS"
    });

    await sheetsService.writeOSHealth(
      "A-SEO-201 Harvest",
      "PASS",
      `Generated ${keywordData.length} keywords from ${seedTerms.length} seeds`,
      { locale, source, count: keywordData.length }
    );

    return keywordData;
  } catch (error: any) {
    console.error('[A-SEO-201] Keyword harvest failed:', error);
    
    await logToAIOutbox({
      agentId: "A-SEO-201",
      task: "harvest-keywords",
      input: JSON.stringify(input),
      output: "",
      status: "ERROR",
      errorMessage: error.message
    });

    throw new Error(`Keyword harvest failed: ${error.message}`);
  }
}

/**
 * A-SEO-202 "Cluster Architect"
 * Clusters keywords using AI-powered semantic analysis
 */
export async function clusterKeywords(): Promise<ClusterResult[]> {
  const keywords = await sheetsService.readSheet<any>('SEO_Keywords');
  
  if (keywords.length === 0) {
    throw new Error('No keywords found in SEO_Keywords sheet');
  }

  const keywordList = keywords.map(k => k.Keyword).filter(Boolean);

  const prompt = `You are A-SEO-202 "Cluster Architect", an AI specialized in semantic keyword clustering for SEO.

Analyze these keywords and group them into thematic clusters: ${keywordList.join(", ")}

For each keyword, determine:
1. **cluster**: A concise cluster name (e.g., "Beard Care Products", "Hair Growth Solutions", "Grooming How-To")
2. **intent**: One of: Informational, Commercial, Transactional, Navigational

**Clustering Rules**:
- Create 3-8 meaningful clusters
- Group by semantic similarity, not just word matching
- Consider user intent and buyer journey stage
- Cluster names should be clear and actionable

Return a JSON array with format: [{"keyword": "...", "cluster": "...", "intent": "..."}]`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        {
          role: "system",
          content: "You are A-SEO-202, an expert in semantic keyword clustering. Return only valid JSON arrays."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      max_completion_tokens: 4096,
    });

    const content = response.choices[0]?.message?.content || "{}";
    const parsed = JSON.parse(content);
    const results: ClusterResult[] = parsed.keywords || parsed.results || [];

    await logToAIOutbox({
      agentId: "A-SEO-202",
      task: "cluster-keywords",
      input: JSON.stringify({ count: keywordList.length }),
      output: JSON.stringify({ clustered: results.length }),
      status: "SUCCESS"
    });

    await sheetsService.writeOSHealth(
      "A-SEO-202 Cluster",
      "PASS",
      `Clustered ${results.length} keywords`,
      { clustered: results.length }
    );

    return results;
  } catch (error: any) {
    console.error('[A-SEO-202] Clustering failed:', error);
    
    await logToAIOutbox({
      agentId: "A-SEO-202",
      task: "cluster-keywords",
      input: JSON.stringify({ count: keywordList.length }),
      output: "",
      status: "ERROR",
      errorMessage: error.message
    });

    throw new Error(`Clustering failed: ${error.message}`);
  }
}

/**
 * A-SEO-203 "Priority Calculator"
 * Calculates priority score: f(Volume, KD, CPC, BusinessFit)
 */
export async function prioritizeKeywords(): Promise<PriorityResult[]> {
  const keywords = await sheetsService.readSheet<any>('SEO_Keywords');
  
  if (keywords.length === 0) {
    throw new Error('No keywords found in SEO_Keywords sheet');
  }

  const results: PriorityResult[] = keywords.map(kw => {
    const volume = parseFloat(kw.Volume_Est || "0");
    const kd = parseFloat(kw.KD_Est || "50");
    const cpc = parseFloat(kw.CPC_EUR_Est || "0");
    const businessFit = kw.BusinessFit || "MEDIUM";

    const businessFitScore = businessFit === "HIGH" ? 1.5 : businessFit === "MEDIUM" ? 1.0 : 0.5;
    
    const priorityScore = (
      (volume / 100) * 0.3 +
      ((100 - kd) / 100) * 0.3 +
      (cpc * 10) * 0.2 +
      (businessFitScore * 50) * 0.2
    );

    return {
      keyword: kw.Keyword || "",
      priorityScore: Math.round(priorityScore * 100) / 100
    };
  });

  results.sort((a, b) => b.priorityScore - a.priorityScore);

  await sheetsService.writeOSHealth(
    "A-SEO-203 Prioritize",
    "PASS",
    `Calculated priority for ${results.length} keywords`,
    { count: results.length }
  );

  return results;
}

/**
 * A-SEO-204 "Brief Generator"
 * Generates comprehensive SEO content briefs with AI
 */
export async function generateBrief(keyword: string): Promise<SEOBrief> {
  const products = await sheetsService.readSheet<any>('FinalPriceList');
  const relevantProducts = products
    .filter(p => p.Category || p.Name)
    .slice(0, 10)
    .map(p => `${p.Name} (${p.Category || 'N/A'})`)
    .join(", ");

  const prompt = `You are A-SEO-204 "Brief Generator", an AI specialized in creating SEO content briefs for B2B trading operations.

Create a comprehensive SEO content brief for the keyword: "${keyword}"

**Context**:
- MH Trading OS - B2B platform for grooming products (beard care, hair care, skincare)
- Target market: Germany and Europe
- Available product lines: ${relevantProducts || "Beard Care, Hair Care, Skincare"}

**Brief Requirements**:
1. **TitleTag**: SEO-optimized title (max 60 chars) - must include target keyword
2. **MetaDescription**: Compelling meta description (max 155 chars)
3. **H1**: Main heading for the page
4. **OutlineJSON**: Detailed content outline in JSON format with sections, H2s, H3s, and key points
5. **InternalLinksCSV**: Suggested internal links (e.g., "/beard-care/,/hair-growth/,/product-reviews/")
6. **TargetURL**: Suggested URL slug (e.g., "/beard-care-guide/")

**Content Strategy**:
- Match search intent (Informational/Commercial/Transactional)
- Include relevant product mentions naturally
- Provide genuine value to B2B buyers
- Professional, authoritative tone
- Focus on business benefits and ROI

Return JSON with fields: titleTag, metaDescription, h1, outlineJSON (as stringified JSON), internalLinksCSV, targetURL`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        {
          role: "system",
          content: "You are A-SEO-204, an expert SEO content strategist. You create comprehensive, actionable content briefs in JSON format."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      max_completion_tokens: 4096,
    });

    const content = response.choices[0]?.message?.content || "{}";
    const parsed = JSON.parse(content);

    const briefId = `BRIEF-${nanoid(8)}`;
    const brief: SEOBrief = {
      BriefID: briefId,
      Keyword: keyword,
      TargetURL: parsed.targetURL || `/${keyword.toLowerCase().replace(/\s+/g, '-')}/`,
      TitleTag: parsed.titleTag || keyword,
      MetaDescription: parsed.metaDescription || `Learn about ${keyword}`,
      H1: parsed.h1 || keyword,
      OutlineJSON: typeof parsed.outlineJSON === 'string' 
        ? parsed.outlineJSON 
        : JSON.stringify(parsed.outlineJSON || parsed.outline || {}),
      InternalLinksCSV: parsed.internalLinksCSV || parsed.internalLinks || "",
      Status: "DRAFT",
      AssignedTo: "Marketing Team",
      CreatedAt: new Date().toISOString(),
      Notes: `AI-generated by A-SEO-204 for keyword: ${keyword}`
    };

    await logToAIOutbox({
      agentId: "A-SEO-204",
      task: "generate-brief",
      input: JSON.stringify({ keyword }),
      output: JSON.stringify({ briefId }),
      status: "SUCCESS"
    });

    await sheetsService.writeOSHealth(
      "A-SEO-204 Brief",
      "PASS",
      `Generated brief ${briefId} for "${keyword}"`,
      { keyword, briefId }
    );

    return brief;
  } catch (error: any) {
    console.error('[A-SEO-204] Brief generation failed:', error);
    
    await logToAIOutbox({
      agentId: "A-SEO-204",
      task: "generate-brief",
      input: JSON.stringify({ keyword }),
      output: "",
      status: "ERROR",
      errorMessage: error.message
    });

    throw new Error(`Brief generation failed: ${error.message}`);
  }
}

/**
 * A-SEO-205 "OnPage Auditor"
 * Suggests on-page SEO improvements for existing pages
 */
export async function onPageSuggest(url: string): Promise<OnPageSuggestion> {
  const prompt = `You are A-SEO-205 "OnPage Auditor", an AI specialized in on-page SEO analysis and optimization.

Analyze the URL: "${url}" and provide on-page SEO suggestions.

**Analysis Areas**:
1. Title tag optimization
2. H1 tag optimization
3. Meta description optimization
4. Content length (target word count)
5. H2 structure and suggestions
6. Quick wins (easy improvements)

**Context**:
- MH Trading OS - B2B grooming products platform
- Focus on practical, high-impact improvements
- Consider German market SEO best practices

Return JSON with fields:
- titleSuggestion: Optimized title tag
- h1Suggestion: Optimized H1
- metaSuggestion: Optimized meta description
- wordCountTarget: Recommended word count (number)
- h2sSuggested: Comma-separated H2 headings
- quickWins: Comma-separated list of easy improvements`;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-5",
      messages: [
        {
          role: "system",
          content: "You are A-SEO-205, an expert on-page SEO auditor. You provide actionable, specific recommendations in JSON format."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      max_completion_tokens: 2048,
    });

    const content = response.choices[0]?.message?.content || "{}";
    const parsed = JSON.parse(content);

    const suggestion: OnPageSuggestion = {
      url,
      titleSuggestion: parsed.titleSuggestion || parsed.title || "Optimize title",
      h1Suggestion: parsed.h1Suggestion || parsed.h1 || "Optimize H1",
      metaSuggestion: parsed.metaSuggestion || parsed.meta || "Optimize meta",
      wordCountTarget: parseInt(parsed.wordCountTarget || "1500"),
      h2sSuggested: parsed.h2sSuggested || parsed.h2s || "",
      quickWins: parsed.quickWins || "Add alt text, Improve internal links, Optimize images"
    };

    await logToAIOutbox({
      agentId: "A-SEO-205",
      task: "onpage-suggest",
      input: JSON.stringify({ url }),
      output: JSON.stringify(suggestion),
      status: "SUCCESS"
    });

    await sheetsService.writeOSHealth(
      "A-SEO-205 OnPage",
      "PASS",
      `Analyzed ${url}`,
      { url }
    );

    return suggestion;
  } catch (error: any) {
    console.error('[A-SEO-205] OnPage analysis failed:', error);
    
    await logToAIOutbox({
      agentId: "A-SEO-205",
      task: "onpage-suggest",
      input: JSON.stringify({ url }),
      output: "",
      status: "ERROR",
      errorMessage: error.message
    });

    throw new Error(`OnPage analysis failed: ${error.message}`);
  }
}

/**
 * A-SEO-206 "Internal Link Mapper"
 * Generates internal linking suggestions based on keywords and content clusters
 */
export async function internalLinkMap(): Promise<Record<string, string[]>> {
  const briefs = await sheetsService.readSheet<any>('SEO_Briefs');
  const keywords = await sheetsService.readSheet<any>('SEO_Keywords');

  if (briefs.length === 0 || keywords.length === 0) {
    return {};
  }

  const clusters = Array.from(new Set(keywords.map((k: any) => k.Cluster).filter(Boolean)));
  
  const linkMap: Record<string, string[]> = {};

  briefs.forEach((brief: any) => {
    const briefKeyword = brief.Keyword || "";
    const briefCluster = keywords.find((k: any) => k.Keyword === briefKeyword)?.Cluster || "";
    
    const relatedBriefs = briefs
      .filter((b: any) => {
        const bCluster = keywords.find((k: any) => k.Keyword === b.Keyword)?.Cluster || "";
        return b.BriefID !== brief.BriefID && bCluster === briefCluster;
      })
      .map((b: any) => b.TargetURL || "")
      .filter(Boolean)
      .slice(0, 5);

    if (relatedBriefs.length > 0) {
      linkMap[brief.BriefID] = relatedBriefs;
    }
  });

  await sheetsService.writeOSHealth(
    "A-SEO-206 LinkMap",
    "PASS",
    `Generated internal link map for ${Object.keys(linkMap).length} briefs`,
    { briefsWithLinks: Object.keys(linkMap).length }
  );

  return linkMap;
}

async function logToAIOutbox(data: {
  agentId: string;
  task: string;
  input: string;
  output: string;
  status: "SUCCESS" | "ERROR";
  errorMessage?: string;
}) {
  try {
    const sheets = await sheetsService['getClient']();
    const timestamp = new Date().toISOString();
    const SPREADSHEET_ID = sheetsService.getSpreadsheetId();
    
    await retryWithBackoff(() =>
      sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID,
        range: 'AI_Outbox!A:H',
        valueInputOption: 'RAW',
        requestBody: {
          values: [[
            timestamp,
            data.agentId,
            data.task,
            data.input.substring(0, 500),
            data.output.substring(0, 500),
            data.status,
            data.errorMessage || '',
            new Date().toISOString()
          ]],
        },
      })
    );
  } catch (error) {
    console.error('Failed to log to AI_Outbox:', error);
  }
}

export const seoEngine = {
  harvestKeywords,
  clusterKeywords,
  prioritizeKeywords,
  generateBrief,
  onPageSuggest,
  internalLinkMap
};
